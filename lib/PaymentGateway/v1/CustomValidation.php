<?php
/**
 * CustomValidation
 * PHP version 7.4
 *
 * @category Class
 * @package  Dana\PaymentGateway\v1
 * @author   DANA Indonesia
 * @link     https://dashboard.dana.id/
 */

/**
 * Payment Gateway API
 *
 * API for doing operations in DANA Payment Gateway (Gapura)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

namespace Dana\PaymentGateway\v1;

use Dana\ApiException;
use Dana\Utils\DateValidation;
use Dana\PaymentGateway\v1\Model\CreateOrderByApiRequest;
use Dana\PaymentGateway\v1\Model\PayOptionDetail;
use Dana\PaymentGateway\v1\Model\CreateOrderByRedirectRequest;

/**
 * CustomValidation Class
 *
 * This class provides custom validation functions for Payment Gateway API requests.
 * Validations are registered in the validationRegistry and executed via CustomValidation().
 */
class CustomValidation
{
    /**
     * Validation registry maps request class names to their validation functions
     *
     * @var callable[]
     */
    /** Money value pattern: digits (1-16) + "." + exactly 2 digits (e.g. 10000.00) */
    private const MONEY_VALUE_PATTERN = '/^\d{1,16}\.\d{2}$/';

    private static $validationRegistry = [
        'Dana\PaymentGateway\v1\Model\CreateOrderByApiRequest' => [
            'validateAdditionalInfoRequired',
            'validateMoneyValuePattern',
            'validateValidUpToCreateOrderRequest',
            'validateExternalStoreIdForQris',
        ],
        'Dana\PaymentGateway\v1\Model\CreateOrderByRedirectRequest' => [
            'validateAdditionalInfoRequired',
            'validateMoneyValuePattern',
            'validateValidUpToCreateOrderRequest',
        ],
        // Add more request types and their validations here as needed
    ];

    /**
     * Perform custom validations on the request based on its type
     *
     * This function uses instanceof checks to determine the request type and runs
     * the appropriate validations from the registry.
     *
     * @param mixed $request The request object to validate (can be any type)
     * @return void
     * @throws ApiException if validation fails
     */
    public static function validate($request)
    {
        if ($request === null) {
            return;
        }

        // Get the class name of the request
        $className = get_class($request);
        
        if ($request instanceof CreateOrderByApiRequest) {
            $className = 'Dana\PaymentGateway\v1\Model\CreateOrderByApiRequest';
        } elseif ($request instanceof CreateOrderByRedirectRequest) {
            $className = 'Dana\PaymentGateway\v1\Model\CreateOrderByRedirectRequest';
        }

        // Check if this request type has validations registered
        if (isset(self::$validationRegistry[$className])) {
            foreach (self::$validationRegistry[$className] as $validatorName) {
                if (method_exists(self::class, $validatorName)) {
                    self::$validatorName($request);
                }
            }
        }
    }

    /**
     * Validate that additionalInfo must exist
     *
     * @param mixed $request The request to validate
     * @return void
     * @throws ApiException if validation fails
     */
    private static function validateAdditionalInfoRequired($request)
    {
        if ($request === null) {
            return;
        }
        if (method_exists($request, 'getAdditionalInfo') && $request->getAdditionalInfo() === null) {
            throw new ApiException(
                'additionalInfo is required',
                0,
                null,
                null
            );
        }
    }

    /**
     * Validate that Money value matches pattern (e.g. 10000.00): ^\d{1,16}\.\d{2}$
     *
     * @param mixed $request The request to validate
     * @return void
     * @throws ApiException if validation fails
     */
    private static function validateMoneyValuePattern($request)
    {
        if ($request === null) {
            return;
        }
        if (!method_exists($request, 'getAmount')) {
            return;
        }
        $amount = $request->getAmount();
        if ($amount === null || !method_exists($amount, 'getValue')) {
            return;
        }
        $value = $amount->getValue();
        if ($value === null || $value === '') {
            throw new ApiException(
                'amount.value is required',
                0,
                null,
                null
            );
        }
        if (!preg_match(self::MONEY_VALUE_PATTERN, $value)) {
            throw new ApiException(
                'amount.value must match pattern (e.g. 10000.00): got ' . $value,
                0,
                null,
                null
            );
        }
    }

    /**
     * Validate validUpTo field in CreateOrderRequest
     *
     *
     * @param mixed $request The request to validate
     * @return void
     * @throws ApiException if validation fails
     */
    private static function validateValidUpToCreateOrderRequest($request)
    {
        if ($request === null) {
            return;
        }
        if (method_exists($request, 'getValidUpTo') && $request->getValidUpTo() !== null) {
            try {
                DateValidation::validateValidUpToDate($request->getValidUpTo());
            } catch (\Exception $e) {
                throw new ApiException(
                    'validUpTo validation failed: ' . $e->getMessage(),
                    0,
                    null,
                    null
                );
            }
        }
    }

    /**
     * Validate that externalStoreId is required when payOption is NETWORK_PAY_PG_QRIS
     *
     * @param mixed $request The request to validate
     * @return void
     * @throws ApiException if validation fails
     */
    private static function validateExternalStoreIdForQris($request)
    {
        if ($request === null) {
            return;
        }

        // Only validate for CreateOrderByApiRequest, not CreateOrderByRedirectRequest
        if (!($request instanceof CreateOrderByApiRequest)) {
            return;
        }

        // Get payOptionDetails
        $payOptionDetails = null;
        $externalStoreId = null;

        if (method_exists($request, 'getPayOptionDetails')) {
            $payOptionDetails = $request->getPayOptionDetails();
        }
        if (method_exists($request, 'getExternalStoreId')) {
            $externalStoreId = $request->getExternalStoreId();
        }

        if (!is_array($payOptionDetails) || empty($payOptionDetails)) {
            return;
        }

        // Check if any payOption is NETWORK_PAY_PG_QRIS
        $hasQris = false;
        foreach ($payOptionDetails as $payOptionDetail) {
            if ($payOptionDetail !== null && method_exists($payOptionDetail, 'getPayOption')) {
                $payOption = $payOptionDetail->getPayOption();
                if ($payOption === PayOptionDetail::PAY_OPTION_NETWORK_PAY_PG_QRIS) {
                    $hasQris = true;
                    break;
                }
            }
        }

        // If QRIS is found, externalStoreId must be provided
        if ($hasQris) {
            if ($externalStoreId === null || (is_string($externalStoreId) && trim($externalStoreId) === '')) {
                throw new ApiException(
                    'externalStoreId is required when payOption is NETWORK_PAY_PG_QRIS',
                    0,
                    null,
                    null
                );
            }
        }
    }

}
